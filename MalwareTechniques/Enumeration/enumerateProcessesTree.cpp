// list all running processes in tree format
#include <Windows.h>
#include <TlHelp32.h>
#include <stdio.h>
using namespace std;
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<DWORD> processes;

vector<DWORD> findSons(DWORD ppid, int i) {
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pEntrySecond;
	pEntrySecond.dwSize = sizeof(PROCESSENTRY32);

	int levels;
	levels = i;

	if (Process32First(hSnapshot, &pEntrySecond)) {
		do {
			DWORD pid = pEntrySecond.th32ProcessID;
			// check if process is new
			if (find(processes.begin(), processes.end(), pid) == processes.end() && pEntrySecond.th32ParentProcessID == ppid) {
				//printf("PID: %d Process Name: %s | PPID: %d\n", pEntrySecond.th32ProcessID, pEntrySecond.szExeFile, pEntrySecond.th32ParentProcessID);
				for (int i = 0; i < levels; ++i) {
					printf(".");
				}
				printf("%s %*s %d\n", pEntrySecond.szExeFile, 51 - levels - 2 - strlen(pEntrySecond.szExeFile), "", pEntrySecond.th32ProcessID);
				processes.push_back(pid);
				findSons(pid, levels + 1);
			}
		} while (Process32Next(hSnapshot, &pEntrySecond));
	}
	return processes;
}

int main(int argc, char* argv[]) {
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE) return 0;

	PROCESSENTRY32 pEntry;
	pEntry.dwSize = sizeof(PROCESSENTRY32);

	// Headers
	printf("%-51s", "Process name");
	printf("%-5s\n", "PID");
	for (int i = 0; i < 50; ++i) {
		printf("-");
	}
	printf(" ");
	for (int i = 0; i < 5; ++i) {
		printf("-");
	}
	printf("\n");

	if (Process32First(hSnapshot, &pEntry)) {
		do {
			DWORD pid = pEntry.th32ProcessID;
			//check if process is new
			if (find(processes.begin(),processes.end(), pid) == processes.end()) {
				//printf("PID: %d Process Name: %s | PPID: %d\n", pEntry.th32ProcessID, pEntry.szExeFile, pEntry.th32ParentProcessID);
				printf("%-50s %d\n", pEntry.szExeFile, pEntry.th32ProcessID);
				processes.push_back(pid);
				findSons(pid, 1);
			}
		} while (Process32Next(hSnapshot, &pEntry));
	}
	CloseHandle(hSnapshot);
	return 0;
}